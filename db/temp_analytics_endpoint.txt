app.get('/api/admin/analytics', requireAuth, (req, res) => {
  try {
    const mainDb = loadMainDb();
    const { timeRange = 'month', year, month, week } = req.query;

    // Use provided year/month/week or default to current
    const now = new Date();
    const selectedYear = year ? parseInt(year, 10) : now.getFullYear();
    const selectedMonth = month ? parseInt(month, 10) : now.getMonth() + 1;
    const selectedWeek = week ? parseInt(week, 10) : Math.floor((now.getDate() - 1) / 7) + 1;

    // Calculate date range based on filter
    let startDate = new Date();
    let endDate = new Date();

    if (timeRange === 'week') {
      // Calculate specific week in specific month
      const firstDayOfMonth = new Date(selectedYear, selectedMonth - 1, 1);
      const dayOfWeekOffset = firstDayOfMonth.getDay(); // 0 = Sunday, 1 = Monday, etc.
      const firstSundayOffset = (7 - dayOfWeekOffset) % 7;

      // Start of the selected week
      const weekStartDate = selectedWeek === 1
        ? firstDayOfMonth
        : new Date(selectedYear, selectedMonth - 1, 1 + firstSundayOffset + (selectedWeek - 2) * 7);

      startDate = new Date(weekStartDate);
      startDate.setHours(0, 0, 0, 0);

      // End of week (Saturday)
      endDate = new Date(weekStartDate);
      endDate.setDate(weekStartDate.getDate() + 6);
      endDate.setHours(23, 59, 59, 999);
    } else if (timeRange === 'month') {
      // Specific month in specific year
      startDate = new Date(selectedYear, selectedMonth - 1, 1);
      endDate = new Date(selectedYear, selectedMonth, 0, 23, 59, 59, 999);
    } else if (timeRange === 'year') {
      // Specific year
      startDate = new Date(selectedYear, 0, 1);
      endDate = new Date(selectedYear, 11, 31, 23, 59, 59, 999);
    }

    // Filter purchases by date range
    const filteredPurchases = mainDb.purchaseHistory.filter(p => {
      const purchaseDate = new Date(p.purchaseDate);
      return purchaseDate >= startDate && purchaseDate <= endDate;
    });

    // Calculate summary statistics with actual prices
    const totalSales = filteredPurchases.reduce((sum, p) => sum + (p.price * p.quantity), 0);
    const totalQuantitySold = filteredPurchases.reduce((sum, p) => sum + p.quantity, 0);
    const uniqueUsers = new Set(filteredPurchases.map(p => p.userId)).size;

    // New vs Old Users Analysis
    const thirtyDaysAgo = new Date();
    thirtyDaysAgo.setDate(now.getDate() - 30);

    const newUsers = mainDb.users.filter(u => {
      const createdDate = new Date(u.accountCreatedDate || u.registrationDate);
      return createdDate >= thirtyDaysAgo;
    });

    const oldUsers = mainDb.users.filter(u => {
      const createdDate = new Date(u.accountCreatedDate || u.registrationDate);
      return createdDate < thirtyDaysAgo;
    });

    // New users in current period
    const newUsersInPeriod = mainDb.users.filter(u => {
      const regDate = new Date(u.accountCreatedDate || u.registrationDate);
      return regDate >= startDate && regDate <= endDate;
    });

    // Aggregate data based on time range
    let dates = [];
    let quantityData = [];
    let salesData = [];
    let trafficData = [];

    if (timeRange === 'week') {
      // Show 7 days (Sunday to Saturday)
      const dayNames = ['Sun', 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat'];
      const dailyData = {};

      // Initialize all 7 days
      for (let i = 0; i < 7; i++) {
        const day = new Date(startDate);
        day.setDate(startDate.getDate() + i);
        const dayKey = day.toISOString().split('T')[0];
        dailyData[dayKey] = { quantity: 0, sales: 0, users: new Set(), dayName: dayNames[day.getDay()] };
      }

      // Aggregate purchases by day
      filteredPurchases.forEach(purchase => {
        const dayKey = new Date(purchase.purchaseDate).toISOString().split('T')[0];
        if (dailyData[dayKey]) {
          dailyData[dayKey].quantity += purchase.quantity;
          dailyData[dayKey].sales += purchase.price * purchase.quantity;
          dailyData[dayKey].users.add(purchase.userId);
        }
      });

      // Convert to arrays
      Object.keys(dailyData).sort().forEach(dayKey => {
        dates.push(dailyData[dayKey].dayName);
        quantityData.push(dailyData[dayKey].quantity);
        salesData.push(dailyData[dayKey].sales);
        trafficData.push(dailyData[dayKey].users.size);
      });

    } else if (timeRange === 'month') {
      // Show weeks in the month
      const weeklyData = {};

      filteredPurchases.forEach(purchase => {
        const pDate = new Date(purchase.purchaseDate);
        const weekStart = new Date(pDate);
        weekStart.setDate(pDate.getDate() - pDate.getDay());
        const weekKey = weekStart.toISOString().split('T')[0];

        if (!weeklyData[weekKey]) {
          weeklyData[weekKey] = { quantity: 0, sales: 0, users: new Set() };
        }
        weeklyData[weekKey].quantity += purchase.quantity;
        weeklyData[weekKey].sales += purchase.price * purchase.quantity;
        weeklyData[weekKey].users.add(purchase.userId);
      });

      // Convert to arrays with week labels
      const weeks = Object.keys(weeklyData).sort();
      weeks.forEach((weekKey, index) => {
        const weekDate = new Date(weekKey);
        dates.push(`Week ${index + 1}`);
        quantityData.push(weeklyData[weekKey].quantity);
        salesData.push(weeklyData[weekKey].sales);
        trafficData.push(weeklyData[weekKey].users.size);
      });

    } else if (timeRange === 'year') {
      // Show all 12 months
      const monthNames = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'];
      const monthlyData = {};

      // Initialize all 12 months
      for (let i = 0; i < 12; i++) {
        monthlyData[i] = { quantity: 0, sales: 0, users: new Set(), monthName: monthNames[i] };
      }

      // Aggregate purchases by month
      filteredPurchases.forEach(purchase => {
        const pDate = new Date(purchase.purchaseDate);
        const monthIndex = pDate.getMonth();
        monthlyData[monthIndex].quantity += purchase.quantity;
        monthlyData[monthIndex].sales += purchase.price * purchase.quantity;
        monthlyData[monthIndex].users.add(purchase.userId);
      });

      // Convert to arrays
      for (let i = 0; i < 12; i++) {
        dates.push(monthlyData[i].monthName);
        quantityData.push(monthlyData[i].quantity);
        salesData.push(monthlyData[i].sales);
        trafficData.push(monthlyData[i].users.size);
      }
    }

    // Week-wise aggregation for last 2 months
    const weeklyData = {};
    const twoMonthsAgo = new Date();
    twoMonthsAgo.setMonth(now.getMonth() - 2);

    const last2MonthsPurchases = mainDb.purchaseHistory.filter(p => {
      const pDate = new Date(p.purchaseDate);
      return pDate >= twoMonthsAgo;
    });

    // Group by week
    last2MonthsPurchases.forEach(purchase => {
      const pDate = new Date(purchase.purchaseDate);
      const weekStart = new Date(pDate);
      weekStart.setDate(pDate.getDate() - pDate.getDay());
      const weekKey = weekStart.toISOString().split('T')[0];

      if (!weeklyData[weekKey]) {
        weeklyData[weekKey] = { sales: 0, quantity: 0, orders: 0 };
      }
      weeklyData[weekKey].quantity += purchase.quantity;
      weeklyData[weekKey].sales += purchase.price * purchase.quantity;
      weeklyData[weekKey].orders += 1;
    });

    const weeklyDates = Object.keys(weeklyData).sort();
    const weeklySales = weeklyDates.map(date => weeklyData[date].sales);
    const weeklyQuantity = weeklyDates.map(date => weeklyData[date].quantity);
    const weeklyOrders = weeklyDates.map(date => weeklyData[date].orders);

    console.log(`ðŸ“Š Analytics Response:`, {
      timeRange,
      startDate: startDate.toISOString().split('T')[0],
      endDate: endDate.toISOString().split('T')[0],
      filteredPurchases: filteredPurchases.length,
      totalQuantity: totalQuantitySold,
      chartDataPoints: dates.length,
      chartLabels: dates
    });

    // User registrations by date
    const userRegistrations = {};
    newUsersInPeriod.forEach(user => {
      const date = user.accountCreatedDate || user.registrationDate;
      userRegistrations[date] = (userRegistrations[date] || 0) + 1;
    });

    const userDates = Object.keys(userRegistrations).sort();
    const userCounts = userDates.map(date => userRegistrations[date]);

    // Top selling products
    const productSales = {};
    filteredPurchases.forEach(purchase => {
      const productId = purchase.productId;
      if (!productSales[productId]) {
        // Find product to get name
        const product = mainDb.products.find(p =>
          p.id === productId || p.productId === productId
        );
        productSales[productId] = {
          productId: productId,
          id: productId,
          productName: purchase.productName || product?.name || 'Unknown Product',
          name: product?.name || purchase.productName || 'Unknown Product',
          quantitySold: 0,
          revenue: 0
        };
      }
      productSales[productId].quantitySold += purchase.quantity;
      productSales[productId].revenue += purchase.price * purchase.quantity;
    });

    const topProducts = Object.values(productSales)
      .sort((a, b) => b.quantitySold - a.quantitySold)
      .slice(0, 10);

    // Category-wise sales
    const categoryData = {};
    filteredPurchases.forEach(purchase => {
      // Match by both id and productId
      const product = mainDb.products.find(p =>
        p.id === purchase.productId || p.productId === purchase.productId
      );
      if (product) {
        const category = product.category || 'Other';
        if (!categoryData[category]) {
          categoryData[category] = { quantity: 0, orders: 0 };
        }
        categoryData[category].quantity += purchase.quantity;
        categoryData[category].orders += 1;
      }
    });

    // Get orders for the selected time range with status breakdown
    const filteredOrders = (mainDb.orders || []).filter(order => {
      const orderDate = new Date(order.orderDate);
      return orderDate >= startDate && orderDate <= endDate;
    }).sort((a, b) => new Date(b.orderDate) - new Date(a.orderDate)).slice(0, 100); // Limit to 100 most recent

    // Categorize orders by status
    const ordersByStatus = {
      pending: filteredOrders.filter(o => o.status === 'pending'),
      processing: filteredOrders.filter(o => o.status === 'processing'),
      shipped: filteredOrders.filter(o => o.status === 'shipped'),
      completed: filteredOrders.filter(o => o.status === 'completed')
    };

    const totalPending = ordersByStatus.pending.length;
    const totalProcessing = ordersByStatus.processing.length;
    const totalShipped = ordersByStatus.shipped.length;
    const totalCompleted = ordersByStatus.completed.length;

    res.json({
      summary: {
        totalSales: totalSales,
        totalQuantitySold,
        totalUserTraffic: uniqueUsers,
        totalOrders: filteredOrders.length,
        ordersByStatus: {
          pending: totalPending,
          processing: totalProcessing,
          shipped: totalShipped,
          completed: totalCompleted
        },
        newUsers: newUsers.length,
        oldUsers: oldUsers.length,
        newUsersInPeriod: newUsersInPeriod.length,
        averageOrderValue: filteredOrders.length > 0 ? totalSales / filteredOrders.length : 0
      },
      charts: {
        dates,
        salesData,
        quantityData,
        trafficData,
        userDates,
        userCounts
      },
      weeklyData: {
        dates: weeklyDates,
        sales: weeklySales,
        quantity: weeklyQuantity,
        orders: weeklyOrders
      },
      userComparison: {
        newUsers: newUsers.length,
        oldUsers: oldUsers.length
      },
      categoryData: Object.keys(categoryData).map(category => ({
        category,
        quantity: categoryData[category].quantity,
        orders: categoryData[category].orders
      })),
      topProducts,
      orders: filteredOrders, // Add orders array for orders view
      ordersByStatus: ordersByStatus, // Orders categorized by status
      timeRange,
      dateRange: {
        start: startDate.toISOString().split('T')[0],
        end: endDate.toISOString().split('T')[0]
      }
    });
  } catch (error) {
    console.error('Analytics error:', error);
    res.status(500).json({ error: 'Failed to fetch analytics' });
  }
